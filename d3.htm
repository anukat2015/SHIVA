<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
<script src="http://code.jquery.com/jquery-1.10.2.min.js"></script>
		<title>D3 Testbed</title>
		<script type="text/javascript" src="d3.v3.min.js"></script>
		<style type="text/css">
		

    </style>
  </head>
  <body>
    <div id="body">
      <div id="footer">
     </div>
    <script type="text/javascript">

	var options={}
	options.lSize=12;
	options.lCol="000";
	options.spacing=180;
	options.nCol="b0c4de";
	options.eCol="ccc";
	options.eWid=1.5;
	options.width=800;
	options.height=600;
	options.trans=1000;
	
	////////////////////////////////////////
	// STYLE
	////////////////////////////////////////
	
	var unselectable={"-moz-user-select":"none","-khtml-user-select":"none",	
		   			  "-webkit-user-select":"none","-ms-user-select":"none",
		   			  "user-select":"none","pointer-events":"none" }

	var	i,id=0,																// Graph globals
		m=[20,options.spacing/2,20,options.spacing/2],					// Margins
		w=options.width- m[1]-m[3],										// Width
		h=options.height-m[0]-m[2],										// Height
		svg,															// V
		dataSet;														// Data 
	
	svg=d3.select("#body").append("svg")								// Create SVG
		.attr("width",w+m[1]+m[3])										// Set width
	    .attr("height",h+m[0]+m[2])										// Height
		.append("g")													// Add element
	
	d3.json("flare.json", function(json) {
		dataSet=json;													// Set data root
		dataSet.x0=h/2;													// Center x
		dataSet.y0=0;													// At top
		
		function toggleAll(d) {											// TOGGLE NODES
			if (d.children) {											// If node has children									
				d.children.forEach(toggleAll);							// Toggle all cildren
				toggle(d);												// Toggle this node
		   		}
		  }
	
		dataSet.children.forEach(toggleAll); 								// Initialize the display to show a few nodes
		toggle(dataSet.children[1]);
		toggle(dataSet.children[1].children[2]);
		toggle(dataSet.children[9]);
		toggle(dataSet.children[9].children[0]);
		redraw();														// Draw
		});

	function redraw(what)												// DRAW
	{
 		 	margins=[0,options.spacing/2,0,options.spacing/2],			// Margins
	   	 	svg.attr("transform","translate("+margins[3]+","+margins[0]+")"); // Move into margin area
	   	 	var tree=d3.layout.tree()									// Create tree layout
		   		.size([h,w]);											// Set size
			var diagonal=d3.svg.diagonal()								// Create link lines
		    	.projection(function(d) { return [d.y, d.x]; });		// Set projection with x/y crossed
  			nodes=tree.nodes(dataSet).reverse();						// Compute the new tree layout.
			nodes.forEach(function(d) { d.y=d.depth*options.spacing; });// Normalize for fixed-depth.
			
			var node=svg.selectAll("g")									// Update the nodes
		      .data(nodes,function(d) { return d.id || (d.id=++id); });	// Get data
	
		var nodeEnter=node.enter().append("g")	  						// Enter any new nodes at the parent's previous position.
			.attr("transform", function(d) { 							// Initial position
				if (d.parent)											// If not dataSet
					return  "translate("+d.parent.y+","+d.parent.x+")"; // Position to parent dot
				else													// If dataSet
					return  "translate("+dataSet.y0+","+dataSet.x0+")"; // Position to dataSet
				})
			.on("click", function(d) { toggle(d); redraw(d); });		// Add click handler
	
		nodeEnter.append("circle")										// Add circle
			.attr("r",1e-6)												// Set size
			.style("stroke","#999")										// Edge
			.style("cursor", function(d) { return d._children ? "pointer" : "auto"; })	// Set cursor based on children
			.style("fill", function(d) { return d._children ? "#"+options.nCol : "#fff"; });	// Set color based on children
	
		nodeEnter.append("text")										// Add label
			.style("font-family","sans-serif")							// San serif
			.attr("x", function(d) { return d.children || d._children ? -10 : 10; })	// Position based on children
			.attr("dy",".3em")
			.attr("text-anchor", function(d) { return d.children || d._children ? "end" : "start"; }) // Set anchor based on children
			.text(function(d) { return d.name; })						// Set name
			.style("fill-opacity", 1e-6)								// Transparent
			.style("fill",options.lCol)									// Color
			.style("font-size",options.lSize)							// Size
			.style(unselectable);										// Unselectable
	
		var nodeUpdate=node.transition()	  							// Transition nodes to their new position
			.duration(options.trans)									// Set time
			.attr("transform", function(d) { return "translate("+d.y+","+d.x+")"; });	// Move
	
		nodeUpdate.select("circle")										// Update circle
			.attr("r",4.5)												// Set size
			.style("fill", function(d) { return d._children ? "#"+options.nCol : "#fff"; });	// Set color based on children
	
		nodeUpdate.select("text")										// Update label
			.style("fill-opacity",1);									// Full alpha
	
		var nodeExit=node.exit().transition()	  						// Transition exiting nodes to the parent's new position.
			.duration(options.trans)									// Set time
			.attr("transform", function(d) { return "translate("+d.parent.y+","+d.parent.x+")"; })	// Move to 1st dot
			.remove();													// Remove
	
		nodeExit.select("circle")										// On circle exit
			.attr("r",1e-6);											// Make really small
	
		nodeExit.select("text")											// On text exit
	      .style("fill-opacity",1e-6);									// Make really transparent
	
		var link=svg.selectAll("path")	  								// Update the links
			.data(tree.links(nodes), function(d) { return d.target.id; });	// Set data
	
		link.enter().insert("path","g")	  								// Enter any new links at the parent's previous position
			.style("fill","none")										// No fule
			.style("stroke",options.eCol)								// Color
			.style("stroke-width",options.eWid)							// Width
			.attr("d", function(d) {									// Set path data
				var o={ x:d.source.x,y:d.source.y };					// dataSet dot											
		        return diagonal({source:o, target:o});					// Create diagonal
				})
		link.transition()	  											// Transition links to their new position
			.duration(options.trans)									// Set time
			.attr("d", diagonal);
	
	 	link.exit().transition()	  									// Transition exiting nodes to the parent's new position
			.duration(options.trans)									// Set time
			.attr("d", function(d) {									// Set path data
	       		var o={ x:d.source.x, y:d.source.y };					// Set dot
	       	 	return diagonal({source:o, target:o});					// Set diagonal
	     		})
			.remove();
	
		nodes.forEach(function(d) {	  									// Stash the old positions for transition
			d.x0=d.x;													// Save x
			d.y0=d.y;													// Y
			});
		}
	
		function toggle(d) {											// CLICK HANDLER
			if (d.children) {											// If it has children
				d._children=d.children;									// Save old children
				d.children=null;										// Clear current children
	  			} 
	  		else{														// If no children
				d.children=d._children;									// Restore old children
				d._children=null;										// Clear saved children
			  	}
		}

	function trace(msg) { console.log(msg) };

    </script>
  </body>
</html>
